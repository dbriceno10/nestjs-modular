Entendiendo la inyecciÃ³n de dependecias
PatrÃ³n de InyecciÃ³n de dependencias:
Es un principio de arquitectura donde nos permite desacoplar las cosas y simplemente un controlador por medio de su constructor puede decir que utiliza el servicio A o el servicio B

Un controlador puede inyectar mas de un servicio, tantos como quiera

Esto se logra a travÃ©s del patrÃ³n singleton, lo que nos permite que una vez creada nuestra clase (servicio) la instancia de nuestro servicio se pueda utilizar para los demÃ¡s controladores, sin necesidad de crear varias instancias del mismo servicio.

Decorador @inyectable
Para que lo anterior funcione en NestJS todos nuestros controladores deben tener el decorador @inyectable que le indica a nestJSque debe manejar esto como una dependencia y cumplir con el patrÃ³n singleton

Un servicio solo pertenece a un Modulo


El tema de la inyecciÃ³n de dependencias puede dar para un curso entero sobre patrones de diseÃ±o, principios SOLID y patrones de arquitectura.

Creo que el profe hizo un resumen lo mas corto posible para entenderlo y no verlo tan abstracto, pero me gustarÃ­a aclarar lo siguientes:

El origen es por los principios SOLID, tenemos la S que se refiere a â€˜Dependency Inversionâ€™ (Inversion de dependecias), que en pocas palabras quieres decir que un sistema flexible es aquel que se refiere a abstracciones.

La â€˜Dependency Injectionâ€™ (Inyeccion de dependencias) es un patron de diseÃ±o que implementa el principio de â€˜Dependency Inversionâ€™ de los principios SOLID ðŸ˜‰


El problema de la referencia circular se puede resolver usando la funciÃ³n forwardRef(), pero como el profesor lo menciona, es una situaciÃ³n que se debe tratar evitar

DocumentaciÃ³n: https://docs.nestjs.com/fundamentals/circular-dependency


Apuntes
Un modulo global serÃ¡ instanciado en todos los demÃ¡s mÃ³dulos si que nosotros tengamos que hacerlo explÃ­citamente.

Creando un modulo global
Para ello creamos un modulo
nest g mo database
Al modulo le agregaremos el decorador global
...
@Global() // Aqui
@Module({})
export class ProductsModule {}Ahora podemos agregar todos los controladores, modulos y providers que necesitemos
import { Module, Global } from '@nestjs/common';

const API_KEY = '12345634';
const API_KEY_PROD = 'PROD1212121SA';

@Global()
@Module({
  providers: [
    {
      provide: 'API_KEY',
      useValue: process.env.NODE_ENV === 'prod' ? API_KEY_PROD : API_KEY,
    },
  ],
  exports: ['API_KEY'],
})
export class DatabaseModule {}
y agregaremos el modulo global al app.module.ts
// src/app.module.ts
...
import { DatabaseModule } from './database/database.module';

@Module({
  imports: [
    ...
    DatabaseModule // ðŸ‘ˆ Use DatabaseModule like global Module
   ],
  ...
})
export class AppModule {}
Listo, ahora podremos usar todos los controladores, modulos y providers que fueron declarados en el modulo global sin tener que instanciar el modulo DatabaseModule en los modulos que se requieran

// src/users/services/users.service.ts

import { Injectable, NotFoundException, Inject } from '@nestjs/common';
..

@Injectable()
export class UsersService {
  constructor(
    private productsService: ProductsService,
    @Inject('API_KEY') private apiKey: string, // ðŸ‘ˆ Inject API_KEY
  ) {}

}
